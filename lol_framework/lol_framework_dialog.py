# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LOLFrameworkDialog
                                 A QGIS plugin
 This plugin estimates life loss resulting from dam failure
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-11-12
        git sha              : $Format:%H$
        copyright            : (C) 2024 by UNBC
        email                : ovu@unbc.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import numpy as np
import pandas as pd
import logging
import math




from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from .lol_framework_dialog_base import Ui_LOLFrameworkDialogBase



# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'lol_framework_dialog_base.ui'))


def classify_and_grade_input(input_data):
    """
    Classifies and grades the input data based on predefined grading standards.

    Args:
        input_data (dict): User input where keys are influencing factors (e.g., 'HD', 'MB', 'WB') and
                           values are the provided inputs.

    Returns:
        list: Graded and normalized inputs.
    """
    grading_standards = {
        'WB': {'Level I (storm, blizzard, typhoon, fog)': 1.0, 'Level II (heavy rain, heavy snow, gale)': 0.8, 'Level III (moderate rain, moderate snow)': 0.6, 'Level IV (light rain, shower, light snow)': 0.4, 'Level V (sunny or cloudy day)': 0.2},
        'MB': {'Overtopping': 1.0, 'Poor quality (leakage, internal erosion, tunnel, blockage or obstruction of dam structure, spillway etc.)': 0.75, 'Mismanagement (Overage storage, poor maintenance, dams without maintenance or management etc.)': 0.5, 'Others': 0.25},
        'TW': {'0-15': 1.0, '15-30': 0.8, '30-45': 0.6, '45-60': 0.4, '>60': 0.2},
        'VB': {'Adobe': 1.0, 'Wood': 0.835, 'Masonry(Brick/Stone)': 0.67, 'Concrete': 0.33},
        'EC': {'Bad': 1.0, 'Middle': 0.67, 'Good': 0.33},
        'UB': {'Vague/Fuzzy': 1.0, 'Clear/Precise': 0.5},
        'TB': {'Midnight (00:00 - 07:59:59)': 1.0, 'Night (20:00 - 23:59:59)': 0.67, 'Daytime (08:00 - 19:59:59)': 0.33},
    }

    normalized_data = []
    for factor, value in input_data.items():
        if factor in grading_standards:  # Non-numeric factors
            graded_value = grading_standards[factor].get(value, None)
            if graded_value is None:
                raise ValueError(f"Invalid value '{value}' for factor '{factor}'.")
            normalized_data.append(graded_value)
        else:  # Numeric factors
            normalized_data.append(value)
    return normalized_data

    pass


def assign_to_matrix(processed_data, SF, matrices_low, matrices_high):
    """
    Assigns processed data to the appropriate matrix group based on SF.

    Args:
        processed_data (list): Graded and normalized data.
        SF (float): Severity of flood.
        matrices_low (list): [XX1, XX2, XX3, XX4].
        matrices_high (list): [XX5, XX6, XX7, XX8].
    """
    target_matrices = matrices_low if SF < 4.6 else matrices_high
    modules = [4, 4, 2, 2]  # Module sizes

    start_idx = 0
    for i, matrix in enumerate(target_matrices):
        module_size = modules[i]
        new_row = processed_data[start_idx:start_idx + module_size]
        if len(new_row) != module_size:
            raise ValueError(f"Data length mismatch for module {i + 1}: Expected {module_size}, got {len(new_row)}.")
        target_matrices[i] = np.vstack([matrix, new_row])
        start_idx += module_size

    pass

def validate_inputs(input_data, expected_fields):
        """
        Validates input data against expected fields.

        Args:
            input_data (dict): User inputs where keys are field names and values are provided inputs.
            expected_fields (dict): Dictionary with field names as keys and value types (e.g., float, str) as values.

        Returns:
            bool: True if all inputs are valid, raises ValueError otherwise.
        """
        for field, field_type in expected_fields.items():
            if field not in input_data:
                raise ValueError(f"Missing input: {field}")
            if not isinstance(input_data[field], field_type):
                raise ValueError(f"Invalid type for {field}. Expected {field_type.__name__}.")
        return True

def initialize_matrices():
        """
        Initializes matrices for low and high severity cases.

        Returns:
            dict: Dictionary containing 'low' and 'high' severity matrices.
        """
        return {
            "low": [np.empty((0, 4)), np.empty((0, 4)), np.empty((0, 2)), np.empty((0, 2))],
            "high": [np.empty((0, 4)), np.empty((0, 4)), np.empty((0, 2)), np.empty((0, 2))]
        }


def process_matrix_in_memory(matrix, display=True):
    """
    Processes a matrix in memory and optionally displays the normalized adjusted result
    and multiplication sum results.

    Args:
        matrix (np.array): The matrix to process.
        display (bool): Whether to display the normalized adjusted result and multiplication sum results.

    Returns:
        dict: Contains the processed results (normalized adjusted result and multiplication sum results).
    """
    try:
        # Perform matrix operations
        CC = np.max(matrix, axis=0)
        BB = np.diag(CC)
        YY = np.matmul(matrix, np.linalg.pinv(BB))

        sum_YY = np.sum(YY, axis=0)
        PP = np.diag(sum_YY)
        ff = np.matmul(YY, np.linalg.pinv(PP))

        ff_log = np.where(ff > 0, np.log(ff), 0)
        ff_final = ff * ff_log

        sum_ff_final = np.sum(ff_final, axis=0)
        count_columns = ff_final.shape[0]
        ln_count = np.log(count_columns)
        final_result = -sum_ff_final / ln_count

        adjusted_result = 1 - final_result
        sum_adjusted_result = np.sum(adjusted_result)
        normalized_adjusted_result = adjusted_result / sum_adjusted_result

        # Correct computation for multiplication sum results
        # Ensure normalized_adjusted_result is a 1D array
        normalized_adjusted_result = normalized_adjusted_result.flatten()

        # Compute multiplication sum results
        multiplication_sum_results = []
        for i in range(YY.shape[0]):
            if normalized_adjusted_result.size == YY.shape[1]:  # Check for correct dimensions
                row_result = np.sum(YY[i, :] * normalized_adjusted_result)
                multiplication_sum_results.append([row_result])
            else:
                raise ValueError("Mismatch in dimensions between YY and normalized_adjusted_result.")

        # Convert results to numpy array
        multiplication_sum_results = np.array(multiplication_sum_results)

        # Log and print results
        if display:
            #logging.info("==== Results for Processed Matrix ====")
            #logging.info(f"Normalized Adjusted Result:\n{normalized_adjusted_result}")
            logging.info(f"Multiplication Sum Results:\n{multiplication_sum_results}")

            #print("\n==== Results for Processed Matrix ====")
            #print("Normalized Adjusted Result:", normalized_adjusted_result)
            print("Multiplication Sum Results:", multiplication_sum_results)
            #sys.stdout.flush()  # Ensure it appears in the console

        return {
            "normalized_adjusted_result": normalized_adjusted_result,
            "multiplication_sum_results": multiplication_sum_results,
        }
    except Exception as e:
        logging.error(f"Error processing matrix in memory: {e}")
        return None


def calculate_fatality_rate_low(Y):
    """
    Calculates fatality rate FL for low severity using the provided equation.

    Args:
        Y (list or array): Multiplication sum results [Y1, Y2, Y3, Y4].

    Returns:
        float: Calculated fatality rate FL (low severity).
    """
    Y1, Y2, Y3, Y4 = Y
    FL = (
        1.1270 +
        1.2347 * np.log(Y1) +
        0.4266 * np.sqrt(Y2) +
        1.0421 * np.exp(Y3) -
        1.3593 * np.sqrt(Y4) -
        0.0629 * (np.log(Y1)**2) -
        0.1314 * np.log(Y1) * np.sqrt(Y2) -
        0.5220 * np.log(Y1) * np.exp(Y3) -
        1.1981 * np.log(Y1) * np.sqrt(Y4) -
        1.9268 * (np.sqrt(Y2)**2) -
        0.0792 * np.sqrt(Y2) * np.exp(Y3) +
        1.6188 * np.sqrt(Y2) * np.sqrt(Y4) -
        0.8520 * (np.exp(Y3)**2) +
        0.6823 * np.exp(Y3) * np.sqrt(Y4) -
        2.2349 * (np.sqrt(Y4)**2)
    )
    return FL


def calculate_fatality_rate_high(Y):
    """
    Calculates fatality rate FL for high severity using the provided equation.

    Args:
        Y (list or array): Multiplication sum results [Y1, Y2, Y3, Y4].

    Returns:
        float: Calculated fatality rate FL (high severity).
    """
    Y1, Y2, Y3, Y4 = Y
    FL = (
        -2.2533 +
        11.3349 * Y1**2 -
        0.1300 * (1 / Y2) -
        0.0378 * (1 / Y3) +
        2.6903 * np.exp(Y4) +
        12.7990 * (Y1**2)**2 -
        4.2117 * Y1**2 * (1 / Y2) +
        0.4114 * Y1**2 * (1 / Y3) -
        6.6235 * Y1**2 * np.exp(Y4) +
        0.0375 * (1 / Y2)**2 +
        0.0009 * (1 / Y2) * (1 / Y3) -
        0.1023 * (1 / Y2) * np.exp(Y4) +
        0.0001 * (1 / Y3)**2 +
        0.0098 * (1 / Y3) * np.exp(Y4) -
        0.5143 * (np.exp(Y4)**2)
    )
    return FL


def calculate_fatality_rate(severity, Y):
    """
    Calculates the fatality rate FL based on severity.

    Args:
        severity (str): Either 'low' or 'high'.
        Y (list or array): Multiplication sum results [Y1, Y2, Y3, Y4].

    Returns:
        float: Fatality rate FL.
    """
    if severity == "low":
        return calculate_fatality_rate_low(Y)
    elif severity == "high":
        return calculate_fatality_rate_high(Y)
    else:
        raise ValueError("Severity must be 'low' or 'high'.")



class LOLFrameworkDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(LOLFrameworkDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.ui = Ui_LOLFrameworkDialogBase()
        self.setupUi(self)

        #self.ui.pButtonRunLOLModel.clicked.connect(self.onpButtonRunLOLModelClicked)
        self.pButtonRunLOLModel.clicked.connect(self.pbuttonrunlolmodelclicked)
        self.matrices = initialize_matrices()
        self.pButtonExport.clicked.connect(self.save_matrices_to_file)
        # Initialize matrices and reset inputs
        self.reset_inputs_and_matrices()

        self.XX1 = np.array([[6.1, 3.71, 1, 99], [92.96, 3.71, 0.75, 31047], [92.96, 2.87, 0.75, 31047],
                [13.41, 2.37, 0.75, 49], [13.41, 2.62, 0.75, 49], [13.41, 2.95, 0.75, 49],
                [13.41, 1.77, 0.75, 49], [6.096, 4.18, 0.75, 17], [11, 0.65, 0.75, 34.8],
                [7.6, 4.18, 0.75, 37]])
        self.XX2 = np.array([[0.67, 0.8, 0.835, 11.27], [0.33, 0.2, 0.67, 19.79], [0.33, 0.2, 0.67, 24.62],
                [0.33, 0.4, 0.835, 9.57], [0.33, 0.4, 0.835, 9.66], [0.33, 0.4, 0.835, 13.2],
                [0.33, 0.4, 0.835, 19.32], [0.67, 0.8, 0.67, 3.21], [0.33, 0.2, 0.835, 1.26],
                [0.33, 0.2, 0.835, 4.02]])
        self.XX3 = np.array([[43000, 0.5], [2987, 1], [4767, 1], [997, 1], [128, 1], [258, 1], [2070, 1],
                [500, 0.5], [50, 0.5], [80, 0.5]])
        self.XX4 = np.array([[1, 1], [0.2, 0.67], [0.2, 0.33], [1, 1], [1, 1], [0.6, 0.67], [0.6, 0.67],
                [1, 1], [1, 1],  [1, 0.67]])
        self.XX5 = np.array([[38.3, 17.882, 1, 1890], [92.96, 26.95,	0.75, 31047], [92.96, 10.08, 0.75, 31047],
                [92.96, 8.83, 0.75, 31047], [13.41, 14.16, 0.75, 49], [13.41, 9.22, 0.75, 49],
                [60, 52.86,	0.75, 4687.2], [20.1, 18.58, 0.75, 95], [20.1, 13.66, 0.75, 95],
                [11.6, 7.9, 0.75, 77.7], [13.1,	9.75, 0.75, 227.12], [14, 11.15, 0.75, 86.3],
                [12.8, 11.15, 1, 55.5], [10.05, 5.57, 1, 178.7], [26.21, 14.59, 0.75, 136],
                [7.9, 16.21, 0.75, 79.8], [5.2,	11.24, 1, 3.1], [5.2, 6.6, 1, 3.1],
                [10.97, 6.97, 0.75, 4.93], [33.00, 33.00, 1, 1100], [47.85, 47.85, 1, 4193.8],
                [21.30, 21.30, 1, 617]])
        self.XX6 = np.array([[0.33, 0.4, 0.835, 22.05], [0.33, 0.2, 1, 8.05], [0.33, 0.2, 0.67, 13.52],
                [0.33, 0.2, 0.67, 14.16], [0.33, 0.4, 0.835, 1.5], [0.33, 0.4, 0.835, 6.78],
                [1,	0.2, 0.835, 29.9], [0.33, 0.2, 0.67, 0.8], [0.33, 0.2, 0.835, 4.8],
                [1,	0.8, 0.67, 1.6], [0.33, 0.2, 0.835, 4.82], [0.33, 0.2, 0.835, 2.4100],
                [1,	0.6, 0.835, 2.4], [0.67, 0.8, 0.835, 1.5], [0.33, 0.20, 1, 11.58],
                [0.33, 0.2, 1, 6.437], [0.33, 0.2, 1, 11.265], [0.33, 0.2, 0.835, 19.31],
                [1, 0.6, 0.835, 1.28], [1, 0.6, 1, 24.14], [0.33, 0.8, 0.835, 8],
                [1, 0.8, 0.67, 60]])
        self.XX7 = np.array([[37700, 1], [2, 1], [536, 1], [1466, 1], [429, 1], [618, 1], [150, 1],
                [100, 0.5], [16400, 0.5], [100, 0.5], [888, 1], [900, 1], [150, 1], [7, 1],
                [50, 1], [25, 1], [275, 1], [4000, 0.5], [8, 0.5], [125, 0.5], [250, 1],
                [5000, 0.5]])
        self.XX8 = np.array([[1, 1], [1,	1], [0.8, 1], [0.6, 0.67], [1, 1], [1, 1], [1, 1], [0.2, 0.33],
                [0.2, 0.33], [1, 1], [1, 0.67], [1,	1], [1,	1], [1,	1], [1,	1], [1,	1],
                [0.8, 0.67], [0.6, 0.33], [1, 1], [1,0.67], [1, 0.33], [0.2, 0.33]])

        #self.comboBoxMB.addItems(['Overtopping', 'Poor quality (leakage, internal erosion, tunnel, \nblockage or obstruction of dam structure, spillway \netc.)', 'Mismanagement (Overage storage, poor maintenance, \ndams without maintenance or management etc.)', 'Others'])
        self.comboBoxMB.setToolTip("Select the dam break mode.")
        self.comboBoxMB.addItems([
            'Overtopping',
            'Poor quality (leakage, internal erosion, tunnel, blockage or obstruction of dam structure, spillway etc.)',
            'Mismanagement (Overage storage, poor maintenance, dams without maintenance or management etc.)',
            'Others'
        ])
        self.comboBoxWB.addItems(['Level I (storm, blizzard, typhoon, fog)', 'Level II (heavy rain, heavy snow, gale)', 'Level III (moderate rain, moderate snow)', 'Level IV (light rain, shower, light snow)', 'Level V (sunny or cloudy day)'])
        self.comboBoxVB.addItems(['Adobe', 'Wood', 'Masonry(Brick/Stone)', 'Concrete'])
        self.comboBoxTW.addItems(['0-15', '15-30', '30-45', '45-60', '>60'])
        self.comboBoxEC.addItems(['Bad', 'Middle', 'Good'])
        self.comboBoxUB.addItems(['Vague/Fuzzy', 'Clear/Precise'])
        self.comboBoxTB.addItems(['Midnight (00:00 - 07:59:59)', 'Daytime (08:00 - 19:59:59)', 'Night (20:00 - 23:59:59)'])

    #clear/reset
    def reset_inputs_and_matrices(self):
        """
        Resets all input fields and calculated matrices.
        Clears any user input and resets calculated matrices in memory.
        """
        # Clear line edits
        self.lineEditHD.clear()
        self.lineEditSF.clear()
        self.lineEditPR.clear()
        self.lineEditSW.clear()
        self.lineEditDD.clear()

        # Reset combo boxes
        self.comboBoxMB.setCurrentIndex(0)
        self.comboBoxWB.setCurrentIndex(0)
        self.comboBoxVB.setCurrentIndex(0)
        self.comboBoxTW.setCurrentIndex(0)
        self.comboBoxEC.setCurrentIndex(0)
        self.comboBoxUB.setCurrentIndex(0)
        self.comboBoxTB.setCurrentIndex(0)

        # Reinitialize matrices (empty them out)
        self.matrices = initialize_matrices()


    def pbuttonrunlolmodelclicked(self):
        # Collect user inputs
        try:
            input_data = {
                'HD': float(self.lineEditHD.text()),
                'SF': float(self.lineEditSF.text()),
                'MB': self.comboBoxMB.currentText(),
                'SW': float(self.lineEditSW.text()),
                'TB': self.comboBoxTB.currentText(),
                'WB': self.comboBoxWB.currentText(),
                'VB': self.comboBoxVB.currentText(),
                'DD': float(self.lineEditDD.text()),  # DD is numeric
                'PR': float(self.lineEditPR.text()),
                'UB': self.comboBoxUB.currentText(),
                'TW': self.comboBoxTW.currentText(),
                'EC': self.comboBoxEC.currentText(),
            }

            # Validate inputs
            expected_fields = {
                'HD': float, 'SF': float, 'MB': str, 'SW': float,
                'TB': str, 'WB': str, 'VB': str, 'DD': float,
                'PR': float, 'UB': str,
                'TW': str, 'EC': str
            }
            validate_inputs(input_data, expected_fields)

            # Normalize and classify inputs
            SF = input_data['SF']
            processed_data = classify_and_grade_input(input_data)

            # Dynamic matrix handling
            if not hasattr(self, "matrices"):
                self.matrices = initialize_matrices()

            matrix_group = "low" if SF < 4.6 else "high"
            assign_to_matrix(processed_data, SF, self.matrices["low"], self.matrices["high"])

            predefined_matrices = {
                "low": [self.XX1, self.XX2, self.XX3, self.XX4],
                "high": [self.XX5, self.XX6, self.XX7, self.XX8],
            }

            # Combine user-inputted data with predefined matrices
            for matrix_group, user_matrices in self.matrices.items():
                for i, user_matrix in enumerate(user_matrices):
                    if user_matrix.size > 0:  # Append user-inputted data if available
                        predefined_matrices[matrix_group][i] = np.vstack(
                            [predefined_matrices[matrix_group][i], user_matrix])

            # Create dictionaries to store results
            multiplication_sum_results = {}
            fatality_rates = {}

            # Process matrices and compute multiplication sum results and fatality rates
            for matrix_group, combined_matrices in predefined_matrices.items():
                if matrix_group == ("low" if SF < 4.6 else "high"):
                    # Process matrices for the selected severity
                    for i, combined_matrix in enumerate(combined_matrices, start=1):
                        result = process_matrix_in_memory(combined_matrix, display=False)
                        if result:
                            key = f"{matrix_group}_XX{i}"
                            multiplication_sum_results[key] = result["multiplication_sum_results"]

                    # Calculate fatality rate for the selected severity
                    try:
                        Y1 = multiplication_sum_results[f"{matrix_group}_XX1"][-1][0]  # Last row of selected matrix
                        Y2 = multiplication_sum_results[f"{matrix_group}_XX2"][-1][0]  # Last row of selected matrix
                        Y3 = multiplication_sum_results[f"{matrix_group}_XX3"][-1][0]  # Last row of selected matrix
                        Y4 = multiplication_sum_results[f"{matrix_group}_XX4"][-1][0]  # Last row of selected matrix
                        Y = [Y1, Y2, Y3, Y4]

                        FL = calculate_fatality_rate(matrix_group, Y)
                        fatality_rates[matrix_group] = FL
                        logging.info(f"Fatality Rate ({matrix_group.capitalize()} Severity): {FL}")

                        # Update labelFatality with the calculated Fatality Rate
                        self.labelFatality.setText(f"{FL:.4f}")  # Display Fatality Rate

                        # Now multiply Fatality Rate by PR and update labelLOL
                        PR = input_data['PR']
                        result_Lol = FL * PR
                        self.labelLOL.setText(f"{round(result_Lol)}")  # Display Fatality Rate * PR

                        # Switch to the Results tab
                        self.tabWidget.setCurrentIndex(2)

                        # Now, call method to save matrices and results
                        #self.save_matrices_to_file(fatality_rates, multiplication_sum_results, predefined_matrices)

                    except KeyError as e:
                        logging.error(f"Error extracting {matrix_group} severity results: {e}")
                        self.labelLOL.setText(f"Error: {e}")

        except ValueError as ve:
            self.labelLOL.setText(f"Input Error: {ve}")
            logging.error(f"Validation error: {ve}")
        except Exception as e:
            self.labelLOL.setText(f"Processing Error: {e}")
            logging.error(f"Unexpected error: {e}")


    def save_matrices_to_file(self, fatality_rates, multiplication_sum_results, predefined_matrices, filename=None):
        """Saves matrices, results, and fatality rates to an Excel file."""
        try:
            # Allow user to save file using QFileDialog
            if not filename:
                from PyQt5.QtWidgets import QFileDialog
                filename, _ = QFileDialog.getSaveFileName(self, "Save Matrices", "", "Excel Files (*.xlsx)")
                if not filename:
                    self.labelLOL.setText("Save operation canceled.")
                    return

            # Write matrices and results to file
            with pd.ExcelWriter(filename) as writer:
                for matrix_group, combined_matrices in predefined_matrices.items():
                    for i, combined_matrix in enumerate(combined_matrices, start=1):
                        sheet_name = f"{matrix_group}_XX{i}"
                        pd.DataFrame(combined_matrix).to_excel(writer, sheet_name=sheet_name, index=False, header=False)

                # Write multiplication sum results
                for key, mult_sum_result in multiplication_sum_results.items():
                    sheet_name = f"{key}_mult_sum_result"
                    pd.DataFrame(mult_sum_result).to_excel(writer, sheet_name=sheet_name, index=False, header=False)

                # Write fatality rates
                fatality_rate_df = pd.DataFrame.from_dict(fatality_rates, orient="index", columns=["Fatality Rate"])
                fatality_rate_df.to_excel(writer, sheet_name="Fatality Rates", index=True, header=True)

            self.labelArea.setText(f"Matrices, results, and fatality rates successfully exported to {filename}.")
        except Exception as e:
            self.labelArea.setText(f"Error saving matrices, results, and fatality rates: {e}")
            logging.error(f"Error saving matrices, results, and fatality rates: {e}")



